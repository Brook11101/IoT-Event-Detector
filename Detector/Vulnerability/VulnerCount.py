import ast
import copy
import numpy as np

from Detector.Vulnerability import RuleSet

deviceStatus = {
    "Smoke": ["unsmoke", "smoke"],
    "Location": ["home", "away"],
    "WaterLeakage": ["unleak", "leak"],
    "MijiaCurtain1": ["open", "close"],
    "MijiaCurtain2": ["open", "close"],
    "YeelightBulb": ["open", "close"],
    "SmartThingsDoorSensor": ["open", "close", "detect", "undetect"],
    "MijiaDoorLock": ["open", "close"],
    "RingDoorbell": ["open", "close", "ring"],
    "iRobotRoomba": ["open", "close", "dock"],
    "AlexaVoiceAssistance": ["open", "close", "openhuelights", "closehuelights", "openLamps", "openCutrain", "singsong",
                             "alarm"],
    "PhilipsHueLight": ["open", "close"],
    "MideaAirConditioner": ["open", "close"],
    "NetatmoWeatherStation": ["open", "close", "windy", "rain", "sun", "unrain", "AirPressureRises",
                              "CarbonDioxideRise", "noise"],
    "YeelightCeilingLamp1": ["open", "close"],
    "YeelightCeilingLamp2": ["open", "close"],
    "YeelightCeilingLamp3": ["open", "close"],
    "YeelightCeilingLamp5": ["open", "close"],
    "YeelightCeilingLamp6": ["open", "close"],
    "WemoSmartPlug": ["open", "close"],
    "WyzeCamera": ["open", "close", "detect", "alert", "disable", "enable", "COalarm"],
    "SmartLifePIRmotionsensor1": ["open", "close", "detect", "undetect"],
    "SmartLifePIRmotionsensor2": ["open", "close", "detect", "undetect"],
    "SmartLifePIRmotionsensor3": ["open", "close", "detect", "undetect"],
    "MijiaPurifier": ["open", "close"],
    "MijiaProjector": ["open", "close"],
    "Notification": ["notify"]
}


def changeStatus(device):
    """随机给定设备分配一个新的状态索引"""
    status_count = len(deviceStatus[device])
    return np.random.randint(0, status_count)


def updateOfficeStatus(office):
    """
    随机改变 office 内所有设备的状态，并返回实际发生改变的设备及其新状态列表。
    例如：[['MijiaCurtain1', 1], ['Smoke', 0], ...]
    """
    old_office = copy.copy(office)
    devices = list(deviceStatus.keys())

    for dev in devices:
        office[dev] = changeStatus(dev)

    ans = []
    for dev in office:
        if office[dev] != old_office[dev]:
            ans.append([dev, office[dev]])
    return ans


def runRules(office, Triggers, rules, id, log_file_path):
    """
    执行规则，生成静态日志，并写入日志文件
    """
    triggerId = {}
    epoch = 0
    logs = []
    time = int(office["time"])
    Actions = []
    actionId = {}

    rulesCountPerEpoch = []

    for i in range(len(Triggers)):
        triggerId[str(Triggers[i])] = 0

    while len(Triggers) != 0 and epoch < 10:
        potentialRules = findPotentialRules(Triggers, rules)
        # 随机打乱，不放回抽样
        potentialRules = np.random.choice(potentialRules, len(potentialRules), False)

        round_rule_count = len(potentialRules)
        rulesCountPerEpoch.append(round_rule_count)

        for rule in potentialRules:
            # 条件不满足，跳过执行
            if len(rule['Condition']) != 0 and (
                    (rule['Condition'][0] == 'time' and int(rule['Condition'][1]) != int(office["time"])) or office[
                rule['Condition'][0]] != rule['Condition'][1]):
                temp = copy.copy(rule)
                temp["id"] = id
                temp["status"] = "skipped"
                temp["time"] = time
                if triggerId[str(rule["Trigger"])] == 0:
                    temp["triggerId"] = id
                else:
                    temp["triggerId"] = triggerId[str(rule["Trigger"])]
                temp["actionIds"] = []
                temp["ancestor"] = ""
                logs.append(temp)
            else:
                # 生成记录
                temp = copy.copy(rule)
                temp["id"] = id
                temp["status"] = "run"
                temp["time"] = time
                # 没有triggerId就用当前的id，说明是一个新触发的trigger
                if triggerId[str(rule["Trigger"])] == 0:
                    temp["triggerId"] = id
                    temp["ancestor"] = id
                else:
                    temp["triggerId"] = triggerId[str(rule["Trigger"])]
                    temp["ancestor"] = ""
                temp["actionIds"] = []
                logs.append(temp)

                # 添加新的Action
                for item in rule["Action"]:
                    # 动作执行，修改房间状态
                    office[item[0]] = item[1]
                    Actions.append(item)
                    actionId[str(item)] = id
            id += 1

        Triggers = Actions
        triggerId = actionId
        Actions = []
        actionId = {}
        epoch += 1

    for log in logs:
        if log["ancestor"] == "":
            for i in range(len(logs)):
                if logs[i]["id"] == log["triggerId"]:
                    log["ancestor"] = logs[i]["ancestor"]

    with open(log_file_path, "a", encoding="utf-8") as logfile:
        start_idx = 0
        for count in rulesCountPerEpoch:
            end_idx = start_idx + count
            for j in range(start_idx, end_idx):
                logfile.write(str(logs[j]) + "\n")
            logfile.write("\n")
            start_idx = end_idx

    return logs, id


def findPotentialRules(Triggers, rules):
    """用于筛选触发器 (Triggers) 里出现的 => 哪些规则可执行"""
    return [rule for rule in rules if rule["Trigger"] in Triggers]


def run_static_simulation(times=1,
                          log_file_path=r"E:\研究生信息收集\论文材料\IoT-Event-Detector\Detector\Vulnerability\Data\static_logs.txt"):
    """
    运行规则模拟，生成静态日志
    :param times: 运行实验的次数
    :param log_file_path: 结果日志文件的路径
    """
    office = {
        "time": "000000",
        "temperature": 20,
        "humidity": 50,
        "illumination": 50,
        **{device: 0 for device in deviceStatus.keys()}  # 设备初始状态
    }

    rules = RuleSet.get_all_rules()

    # 初始化日志文件（清空）
    with open(log_file_path, "w", encoding="utf-8"):
        pass

    rule_id = 1

    for _ in range(times):
        # print('随机改变场景')
        triggers = updateOfficeStatus(office)

        # print('触发规则')
        logs, rule_id = runRules(office, triggers, rules, rule_id, log_file_path)

    # print(f"=={rule_id} Simulation Done. Logs written to {log_file_path} ==")

    return rule_id


def detectRaceCondition_per_epoch(epochs_logs):
    """
    对每个轮次(epoch)单独执行漏洞检测，包括 UC, CP, Condition Bypass (CBS), 再加一个CBK，踢出了AC。AC的检测需要跨周期

    :param epochs_logs: 轮次划分的日志数据
    :return: vuln_dict: {
                "UC": [...],
                "CP": [...],
                "CBS": [...],
             }
    """
    vuln_dict = {
        "AC": [], "UC": [], "CBK": [], "CP": [],
        "AL": [], "ARN": [], "ART": [], "CBS": [], "CC": []
    }
    logged_pairs = set()  # 用于去重

    for epoch_logs in epochs_logs:
        for i in range(len(epoch_logs)):
            current_rule = epoch_logs[i]
            current_actions = current_rule["Action"]
            cur_rule_id = current_rule["id"]

            # ---------------------- 对于状态为 skipped 的规则 ----------------------
            if current_rule['status'] == 'skipped':
                # Condition Bypass (CBS)：检查前面和后面是否存在相同的 Action
                for j in range(i - 1, -1, -1):
                    former_actions = epoch_logs[j]["Action"]
                    for act in current_actions:
                        if act in former_actions:
                            pair_cbs = (epoch_logs[j]["id"], cur_rule_id)
                            if pair_cbs not in logged_pairs:
                                logged_pairs.add(pair_cbs)
                                vuln_dict["CBS"].append(pair_cbs)
                    # 不 break，以便累计所有匹配
                for j in range(i + 1, len(epoch_logs)):
                    later_actions = epoch_logs[j]["Action"]
                    for act in current_actions:
                        if act in later_actions:
                            pair_cbs = (cur_rule_id, epoch_logs[j]["id"])
                            if pair_cbs not in logged_pairs:
                                logged_pairs.add(pair_cbs)
                                vuln_dict["CBS"].append(pair_cbs)
                # Condition Block (CBK)：如果当前规则带有 Condition，向前回溯查找前面是否修改了 Condition 中对应设备
                if current_rule.get('Condition'):
                    cond_dev = current_rule['Condition'][0]
                    for j in range(i - 1, -1, -1):
                        former_rule = epoch_logs[j]
                        for former_act in former_rule["Action"]:
                            if former_act[0] == cond_dev:
                                pair_cbk = (former_rule["id"], cur_rule_id)
                                if pair_cbk not in logged_pairs:
                                    logged_pairs.add(pair_cbk)
                                    vuln_dict["CBK"].append(pair_cbk)
                                break
                        else:
                            continue
                        break

            # ---------------------- 对于状态为 run 的规则 ----------------------
            if current_rule['status'] == 'run':
                # Action Conflict (AC) / Unexpected Conflict (UC)
                for j in range(i - 1, -1, -1):
                    former_rule = epoch_logs[j]
                    for latter_act in current_actions:
                        for former_act in former_rule["Action"]:
                            if latter_act[0] == former_act[0] and latter_act[1] != former_act[1]:
                                pair = (former_rule["id"], cur_rule_id)
                                if former_rule["ancestor"] == current_rule["ancestor"]:
                                    if pair not in logged_pairs:
                                        pass
                                        # logged_pairs.add(pair)
                                        # vuln_dict["AC"].append(pair)
                                else:
                                    if pair not in logged_pairs:
                                        logged_pairs.add(pair)
                                        vuln_dict["UC"].append(pair)
                # Action Loop (AL), Action Repetition (ARN) 和 Action Revert (ART)
                # 以当前规则的 triggerId 作为回溯链标识
                front = current_rule["triggerId"]
                for j in range(i - 1, -1, -1):
                    former_rule = epoch_logs[j]
                    for act in current_actions:
                        # Action Loop (AL)：若前面的规则中包含相同的 Action，且该规则的 id 与当前的 triggerId 相等
                        if act in former_rule["Action"] and former_rule["id"] == front:
                            pair_al = (former_rule["id"], cur_rule_id)
                            if pair_al not in logged_pairs:
                                pass
                                # logged_pairs.add(pair_al)
                                # vuln_dict["AL"].append(pair_al)
                        # Action Repetition (ARN)：若前面的规则中包含相同的 Action，且两者的 ancestor 相同
                        if act in former_rule["Action"] and former_rule["ancestor"] == current_rule["ancestor"]:
                            pair_arn = (former_rule["id"], cur_rule_id)
                            if pair_arn not in logged_pairs:
                                pass
                                # logged_pairs.add(pair_arn)
                                # vuln_dict["ARN"].append(pair_arn)
                        # Action Revert (ART)：对于前面规则中的每个 Action，
                        # 若与当前规则的某 Action 属于同一设备但状态不同，且该前面规则的 id 等于当前的 triggerId
                        for former_act in former_rule["Action"]:
                            if act[0] == former_act[0] and act[1] != former_act[1] and former_rule["id"] == front:
                                pair_art = (former_rule["id"], cur_rule_id)
                                if pair_art not in logged_pairs:
                                    pass
                                    # logged_pairs.add(pair_art)
                                    # vuln_dict["ART"].append(pair_art)
                    if former_rule["id"] == front:
                        front = former_rule["triggerId"]
                # Condition Pass (CP)：原有逻辑不变
                if current_rule.get('Condition'):
                    cond_dev, cond_state = current_rule['Condition'][0], current_rule['Condition'][1]
                    for j in range(i - 1, -1, -1):
                        former_rule = epoch_logs[j]
                        if [cond_dev, cond_state] in former_rule["Action"]:
                            pair_cp = (former_rule["id"], cur_rule_id)
                            if pair_cp not in logged_pairs:
                                logged_pairs.add(pair_cp)
                                vuln_dict["CP"].append(pair_cp)
                            break
                # Condition Contradictory (CC)：若当前规则和前面某规则均有 Condition，
                # 且针对同一设备但期望状态不同，则记录该冲突
                if current_rule.get('Condition'):
                    for j in range(i - 1, -1, -1):
                        former_rule = epoch_logs[j]
                        if former_rule.get('Condition'):
                            if current_rule['Condition'][0] == former_rule['Condition'][0] and \
                                    current_rule['Condition'][1] != former_rule['Condition'][1]:
                                pair_cc = (former_rule["id"], cur_rule_id)
                                if pair_cc not in logged_pairs:
                                    pass
                                    # logged_pairs.add(pair_cc)
                                    # vuln_dict["CC"].append(pair_cc)
    return vuln_dict


def detectVulnerability_per_epoch(epochs_logs):
    """
    对每个轮次(epoch)单独执行漏洞检测，包括 Race Condition 检测（AC）
    和额外的漏洞检测：Action Loop (AL), Action Repetition (ARN),
    Action Revert (ART), Condition Contradictory (CC).

    :param epochs_logs: 轮次划分的日志数据
    :return: vuln_dict: {
                "AC": [...],
                "UC": [...],
                "CBK": [...],
                "CP": [...],
                "AL": [...],
                "ARN": [...],
                "ART": [...],
                "CBS": [...],
                "CC": [...]
             }
    """
    vuln_dict = {
        "AC": [], "UC": [], "CBK": [], "CP": [],
        "AL": [], "ARN": [], "ART": [], "CBS": [], "CC": []
    }
    logged_pairs = set()  # 用于去重

    for epoch_logs in epochs_logs:
        for i in range(len(epoch_logs)):
            current_rule = epoch_logs[i]
            current_actions = current_rule["Action"]
            cur_rule_id = current_rule["id"]

            # ---------------------- 对于状态为 skipped 的规则 ----------------------
            if current_rule['status'] == 'skipped':
                # Condition Bypass (CBS)：检查前面和后面是否存在相同的 Action
                for j in range(i - 1, -1, -1):
                    former_actions = epoch_logs[j]["Action"]
                    for act in current_actions:
                        if act in former_actions:
                            pair_cbs = (epoch_logs[j]["id"], cur_rule_id)
                            if pair_cbs not in logged_pairs:
                                pass
                                # logged_pairs.add(pair_cbs)
                                # vuln_dict["CBS"].append(pair_cbs)
                    # 不 break，以便累计所有匹配
                for j in range(i + 1, len(epoch_logs)):
                    later_actions = epoch_logs[j]["Action"]
                    for act in current_actions:
                        if act in later_actions:
                            pair_cbs = (cur_rule_id, epoch_logs[j]["id"])
                            if pair_cbs not in logged_pairs:
                                pass
                                # logged_pairs.add(pair_cbs)
                                # vuln_dict["CBS"].append(pair_cbs)
                # Condition Block (CBK)：如果当前规则带有 Condition，向前回溯查找前面是否修改了 Condition 中对应设备
                if current_rule.get('Condition'):
                    cond_dev = current_rule['Condition'][0]
                    for j in range(i - 1, -1, -1):
                        former_rule = epoch_logs[j]
                        for former_act in former_rule["Action"]:
                            if former_act[0] == cond_dev:
                                pair_cbk = (former_rule["id"], cur_rule_id)
                                if pair_cbk not in logged_pairs:
                                    pass
                                    # logged_pairs.add(pair_cbk)
                                    # vuln_dict["CBK"].append(pair_cbk)
                                break
                        else:
                            continue
                        break

            # ---------------------- 对于状态为 run 的规则 ----------------------
            if current_rule['status'] == 'run':
                # Action Conflict (AC) / Unexpected Conflict (UC)
                for j in range(i - 1, -1, -1):
                    former_rule = epoch_logs[j]
                    for latter_act in current_actions:
                        for former_act in former_rule["Action"]:
                            if latter_act[0] == former_act[0] and latter_act[1] != former_act[1]:
                                pair = (former_rule["id"], cur_rule_id)
                                if former_rule["ancestor"] == current_rule["ancestor"]:
                                    if pair not in logged_pairs:
                                        logged_pairs.add(pair)
                                        vuln_dict["AC"].append(pair)
                                # else:
                                #     if pair not in logged_pairs:
                                #         logged_pairs.add(pair)
                                #         vuln_dict["UC"].append(pair)
                # Action Loop (AL), Action Repetition (ARN) 和 Action Revert (ART)
                # 以当前规则的 triggerId 作为回溯链标识
                front = current_rule["triggerId"]
                for j in range(i - 1, -1, -1):
                    former_rule = epoch_logs[j]
                    for act in current_actions:
                        # Action Loop (AL)：若前面的规则中包含相同的 Action，且该规则的 id 与当前的 triggerId 相等
                        if act in former_rule["Action"] and former_rule["id"] == front:
                            pair_al = (former_rule["id"], cur_rule_id)
                            if pair_al not in logged_pairs:
                                logged_pairs.add(pair_al)
                                vuln_dict["AL"].append(pair_al)
                        # Action Repetition (ARN)：若前面的规则中包含相同的 Action，且两者的 ancestor 相同
                        elif act in former_rule["Action"] and former_rule["ancestor"] == current_rule["ancestor"]:
                            pair_arn = (former_rule["id"], cur_rule_id)
                            if pair_arn not in logged_pairs:
                                logged_pairs.add(pair_arn)
                                vuln_dict["ARN"].append(pair_arn)

                        else:
                            # Action Revert (ART)：对于前面规则中的每个 Action，
                            # 若与当前规则的某 Action 属于同一设备但状态不同，且该前面规则的 id 等于当前的 triggerId
                            for former_act in former_rule["Action"]:
                                if act[0] == former_act[0] and act[1] != former_act[1] and former_rule["id"] == front:
                                    pair_art = (former_rule["id"], cur_rule_id)
                                    if pair_art not in logged_pairs:
                                        logged_pairs.add(pair_art)
                                        vuln_dict["ART"].append(pair_art)
                    if former_rule["id"] == front:
                        front = former_rule["triggerId"]
                # Condition Pass (CP)：原有逻辑不变
                if current_rule.get('Condition'):
                    cond_dev, cond_state = current_rule['Condition'][0], current_rule['Condition'][1]
                    for j in range(i - 1, -1, -1):
                        former_rule = epoch_logs[j]
                        if [cond_dev, cond_state] in former_rule["Action"]:
                            pair_cp = (former_rule["id"], cur_rule_id)
                            if pair_cp not in logged_pairs:
                                pass
                                # logged_pairs.add(pair_cp)
                                # vuln_dict["CP"].append(pair_cp)
                            break
                # Condition Contradictory (CC)：若当前规则和前面某规则均有 Condition，
                # 且针对同一设备但期望状态不同，则记录该冲突
                if current_rule.get('Condition'):
                    for j in range(i - 1, -1, -1):
                        former_rule = epoch_logs[j]
                        if former_rule.get('Condition'):
                            if current_rule['Condition'][0] == former_rule['Condition'][0] and \
                                    current_rule['Condition'][1] != former_rule['Condition'][1]:
                                pair_cc = (former_rule["id"], cur_rule_id)
                                if pair_cc not in logged_pairs:
                                    logged_pairs.add(pair_cc)
                                    vuln_dict["CC"].append(pair_cc)
    return vuln_dict


def detectVulnAllType(logs):
    vuln_dict = {
        "AC": [], "UC": [], "CBK": [], "CP": [],
        "AL": [], "ARN": [], "ART": [], "CBS": [], "CC": []
    }
    logged_pairs = set()  # 用于去重

    for i in range(len(logs)):
        LatterActions = logs[i]["Action"]
        if logs[i]['status'] == 'skipped':
            # Condition Bypass：skipped的规则，前面或者后面有没有相同的Action
            for j in range(i - 1, -1, -1):
                formerActions = logs[j]["Action"]
                for Latter in LatterActions:
                    if Latter in formerActions:
                        pair_cbk = (logs[j]["id"], logs[i]["id"])
                        if pair_cbk not in logged_pairs:
                            pass
                            # logged_pairs.add(pair_cbk)
                            # vuln_dict["CBK"].append(pair_cbk)

            for j in range(i + 1, len(logs)):
                formerActions = logs[j]["Action"]
                for Latter in LatterActions:
                    if Latter in formerActions:
                        pair_cbs = (logs[i]["id"], logs[j]["id"])
                        if pair_cbs not in logged_pairs:
                            pass
                            # logged_pairs.add(pair_cbs)
                            # vuln_dict["CBS"].append(pair_cbs)
            if len(logs[i]['Condition']) != 0:
                # Condition Block：If door(4) is open, when curtain(1) or curtain(2) is closed, open the Yeelight Bulb(3) skipped的规则，前面有没有规则的修改curtain12的rule
                for j in range(i - 1, -1, -1):
                    formerActions = logs[j]["Action"]
                    Latter = logs[i]["Condition"]
                    for former in formerActions:
                        if Latter[0] == former[0]:
                            pair_cbk = (logs[j]["id"], logs[i]["id"])
                            if pair_cbk not in logged_pairs:
                                pass
                                # logged_pairs.add(pair_cbk)
                                # vuln_dict["CBK"].append(pair_cbk)

        else:
            front = logs[i]["triggerId"]
            for j in range(i - 1, -1, -1):
                formerActions = logs[j]["Action"]

                for Latter in LatterActions:
                    # Action Loop:前面是否有相同的Action，且在一条链上
                    if Latter in formerActions and logs[j]["id"] == front:
                        pair_al = (logs[j]["id"], logs[i]["id"])
                        if pair_al not in logged_pairs:
                            logged_pairs.add(pair_al)
                            vuln_dict["AL"].append(pair_al)

                    # Action Repetition：前面是否有相同的Action，且在一个祖宗上
                    elif Latter in formerActions and logs[j]["ancestor"] == logs[i]["ancestor"]:
                        pair_arn = (logs[j]["id"], logs[i]["id"])
                        if pair_arn not in logged_pairs:
                            logged_pairs.add(pair_arn)
                            vuln_dict["ARN"].append(pair_arn)
                    else:
                        for former in formerActions:
                            # Action Revert：前面是否有相同的设备的Action，不同的status，且在一条链上
                            if Latter[0] == former[0] and logs[j]["id"] == front:
                                pair_art = (logs[j]["id"], logs[i]["id"])
                                if pair_art not in logged_pairs:
                                    logged_pairs.add(pair_art)
                                    vuln_dict["ART"].append(pair_art)


                            # Action Conflict:前面是否有相同的设备的Action，不同的status，且在一个祖宗上
                            elif Latter[0] == former[0] and logs[j]["ancestor"] == logs[i]["ancestor"]:
                                pair = (logs[j]["id"], logs[i]["id"])
                                if pair not in logged_pairs:
                                    logged_pairs.add(pair)
                                    vuln_dict["AC"].append(pair)
                            # unexpected Conflict:相同的设备的Action，不同的status，不在同一个祖宗上
                            elif Latter[0] == former[0] and Latter[1] != former[1]:
                                pair = (logs[j]["id"], logs[i]["id"])
                                # if pair not in logged_pairs:
                                #     logged_pairs.add(pair)
                                #     vuln_dict["AC"].append(pair)
                # Condition Contradictory：没有，在用户构建的规则中，没有能够导致condition Contradictory的规则。如果有，那就是If door(4) is open, when curtain(1) or curtain(2) is closed, open the Yeelight Bulb(3) ，和If door(4) is open, when curtain(1) or curtain(2) is opened, open the xxx。
                if len(logs[i]['Condition']) != 0 and len(logs[j]["Condition"]) != 0 and logs[i]['Condition'][0] == \
                        logs[j]['Condition'][0] \
                        and logs[i]['Condition'][1] != logs[j]['Condition'][1]:
                    pair_cc = (logs[j]["id"], logs[i]["id"])
                    if pair_cc not in logged_pairs:
                        logged_pairs.add(pair_cc)
                        vuln_dict["CC"].append(pair_cc)
                if logs[j]["id"] == front:
                    front = logs[j]["triggerId"]
            if len(logs[i]['Condition']) != 0:
                # Condition Pass：If door(4) is open, when curtain(1) or curtain(2) is closed, open the Yeelight Bulb(3) run的规则前面有没有关闭curtain12的rule
                for j in range(i - 1, -1, -1):
                    formerActions = logs[j]["Action"]
                    Latter = logs[i]['Condition']
                    if Latter in formerActions:
                        pair_cp = (logs[j]["id"], logs[i]["id"])
                        if pair_cp not in logged_pairs:
                            pass
                            # logged_pairs.add(pair_cp)
                            # vuln_dict["CP"].append(pair_cp)

    return vuln_dict


def detectVulnerability_all(epochs_logs):
    combined_logs = []
    for epoch in epochs_logs:
        combined_logs.extend(epoch)
    # 将合并后的日志包装为只有一个轮次的列表，保持原有检测逻辑不变
    return detectVulnAllType(combined_logs)


def read_static_logs(
        log_file=r"E:\研究生信息收集\论文材料\IoT-Event-Detector\Detector\Vulnerability\Data\static_logs.txt"):
    """
    读取 `static_logs.txt`，解析成按轮次 (epoch) 分组的日志。
    """
    with open(log_file, "r", encoding="utf-8") as f:
        data = f.read().strip()

    # **按照空行分隔轮次**
    epochs = data.split("\n\n")

    logs_per_epoch = []
    for epoch in epochs:
        log_entries = [ast.literal_eval(line) for line in epoch.split("\n") if line.strip()]
        logs_per_epoch.append(log_entries)

    return logs_per_epoch  # **返回按轮次分组的日志**


def build_conflict_map(vuln_dict):
    """
    根据 vuln_dict 中 AL、ARN、ART、CBS、CC 类型的规则对构造冲突映射 conflict_map。
    conflict_map 的 key 为规则 id，value 为与之冲突的其他规则 id 的集合。
    """
    conflict_map = {}
    # 需要考虑的干扰类型
    conflict_keys = ['AL', 'ARN', 'ART', 'CBS', 'CC']
    for key in conflict_keys:
        # 获取该干扰类型的规则对列表（如果不存在则为空列表）
        for pair in vuln_dict.get(key, []):
            a, b = pair
            # 将 a 和 b 的冲突关系添加到 conflict_map 中
            if a not in conflict_map:
                conflict_map[a] = set()
            if b not in conflict_map:
                conflict_map[b] = set()
            conflict_map[a].add(b)
            conflict_map[b].add(a)
    return conflict_map


def get_conflict_map():
    log_file_path = r"E:\研究生信息收集\论文材料\IoT-Event-Detector\Detector\Vulnerability\Data\static_logs.txt"  # 日志文件路径
    # 读取日志，得到按轮次划分的日志数据
    epochs_logs = read_static_logs(log_file_path)
    vuln_dict1 = detectRaceCondition_per_epoch(epochs_logs)
    vuln_dict2 = detectVulnerability_all(epochs_logs)

    vuln_dict = {}
    for key in vuln_dict1.keys():
        vuln_dict[key] = vuln_dict1[key] + vuln_dict2.get(key, [])
        print(key)
        print(len(vuln_dict[key]))

    print("Vulnerability dict:", vuln_dict)



    # 调用 build_conflict_map 得到冲突映射
    conflict_map = build_conflict_map(vuln_dict)
    print("Conflict Map:", conflict_map)
    print(len(conflict_map.keys()))

    return conflict_map


def get_conflict_count():
    log_file_path = r"E:\研究生信息收集\论文材料\IoT-Event-Detector\Detector\Vulnerability\Data\static_logs.txt"  # 日志文件路径
    # 读取日志，得到按轮次划分的日志数据
    epochs_logs = read_static_logs(log_file_path)
    vuln_dict1 = detectRaceCondition_per_epoch(epochs_logs)
    vuln_dict2 = detectVulnerability_all(epochs_logs)

    vuln_dict = {}
    for key in vuln_dict1.keys():
        vuln_dict[key] = vuln_dict1[key] + vuln_dict2.get(key, [])
        print(key)
        print(len(vuln_dict[key]))
    print("Vulnerability dict:", vuln_dict)

    # 调用 build_conflict_map 得到冲突映射
    conflict_map = build_conflict_map(vuln_dict)
    print("Conflict Map:", conflict_map)
    print(len(conflict_map.keys()))

    # 建立规则 id 到 RuleId 的映射
    ruleid_map = {}
    for epoch in epochs_logs:
        for rule in epoch:
            # 假设日志中每个 rule 包含 "id" 和 "RuleId" 字段
            ruleid_map[rule["id"]] = rule.get("RuleId")

    # 根据 conflict_map 的所有 key，提取其对应的 RuleId，去重后计算个数
    unique_ruleids = set()
    for key in conflict_map.keys():
        rule_id = ruleid_map.get(key)
        if rule_id is not None:
            unique_ruleids.add(rule_id)

    print("Unique RuleId count:", len(unique_ruleids))



def run_vulnerability_count():
    # 设置模拟的次数和运行次数
    simulation_settings = [10]
    runs_per_setting = 1
    log_file_path = r"E:\研究生信息收集\论文材料\IoT-Event-Detector\Detector\Vulnerability\Data\static_logs.txt"  # 日志文件路径

    for sim_time in simulation_settings:
        total_rule_count = 0
        total_vuln_counts = {
            "AC": 0, "UC": 0, "CBK": 0, "CP": 0,
            "AL": 0, "ARN": 0, "ART": 0, "CBS": 0, "CC": 0
        }
        for run in range(runs_per_setting):
            # 清空日志文件
            with open(log_file_path, "w", encoding="utf-8"):
                pass

            # 执行规则模拟，返回触发规则总数量
            rule_count = run_static_simulation(sim_time, log_file_path)
            total_rule_count += rule_count

            # 读取日志，得到按轮次划分的日志数据
            epochs_logs = read_static_logs(log_file_path)

            vuln_dict1 = detectRaceCondition_per_epoch(epochs_logs)
            vuln_dict2 = detectVulnerability_all(epochs_logs)

            vuln_dict = {}
            for key in vuln_dict1.keys():
                vuln_dict[key] = vuln_dict1[key] + vuln_dict2.get(key, [])

            print("Vulnerability dict:", vuln_dict)

            for key, conflict_list in vuln_dict.items():
                total_vuln_counts[key] += len(conflict_list)

            # 调用 build_conflict_map 得到冲突映射
            conflict_map = build_conflict_map(vuln_dict)
            print("Conflict Map:", conflict_map)

        # 计算平均值
        avg_rule_count = total_rule_count / runs_per_setting
        print("模拟次数(times) =", sim_time)
        print("平均触发规则数量:", avg_rule_count)
        for vuln_type in sorted(total_vuln_counts.keys()):
            print("平均", vuln_type, "数量:", total_vuln_counts[vuln_type] / runs_per_setting)
        print("-" * 50)


if __name__ == "__main__":
    get_conflict_count()
