import threading
import time
import random
import ast

from Detector.Vulnerability.VulnerCount import get_conflict_map, detectRaceCondition_per_epoch, detectVulnerability_all

# 全局变量：跨周期记录已成功执行与未执行的规则id
global_executed = set()
global_noexecuted = set()


def read_static_logs(log_file_path):
    """
    读取 static_logs 文件，按空行分隔周期，
    返回一个列表，每个元素为该周期内的规则日志（字典列表）。
    假设每行是一个字典的字符串。
    """
    with open(log_file_path, "r", encoding="utf-8") as f:
        content = f.read().strip()
    epochs = content.split("\n\n")
    epochs_logs = []
    for epoch in epochs:
        logs = []
        for line in epoch.split("\n"):
            line = line.strip()
            if line:
                try:
                    log_entry = ast.literal_eval(line)
                    logs.append(log_entry)
                except Exception as e:
                    print(f"解析日志行出错: {line}, 错误: {e}")
        epochs_logs.append(logs)
    return epochs_logs


def execute_rule(rule, output_list, lock, barrier, conflict_map):
    """
    执行单条规则：
    1. 先等待 barrier，确保所有线程同步启动。
    2. 检查当前规则的冲突集合（来自 conflict_map）是否与 global_executed 中已有的规则id有交集。
       - 如果有，说明冲突，则不执行该规则，将其 id 加入 global_noexecuted
       - 如果没有，则模拟执行该规则（例如延迟模拟），执行成功后将其 id 加入 global_executed
    3. 将规则（无论执行或跳过）的最终状态记录到 output_list（线程安全更新）。
    """
    # 等待所有线程到达屏障
    barrier.wait()

    # 模拟规则执行延迟
    time.sleep(random.uniform(1, 2))

    # 检查冲突
    with lock:
        # 获取当前规则的冲突集合，若不存在则为空集合
        conflict_ids = conflict_map.get(rule["id"], set())
        if conflict_ids & global_executed:
            # 检测到冲突：直接跳过执行
            global_noexecuted.add(rule["id"])
            print(f"规则 {rule['id']} 被跳过，冲突规则 {conflict_ids & global_executed} 已执行")
            return
        else:
            global_executed.add(rule["id"])
            output_list.append(rule)
    print(f"规则 {rule['id']} 执行成功")


def process_epoch(epoch_logs, output_logs, conflict_map):
    """
    处理一个周期内的规则日志：
    1. 遍历 epoch_logs，如果某条规则的 ancestor 在 global_noexecuted 中，则直接跳过该规则，
       并将其 id 加入 global_noexecuted，
    2. 对未跳过的规则，创建一个 Barrier，启动线程并同步启动执行（调用 execute_rule）。
    3. 等待所有线程执行完毕，将本周期所有规则日志记录到 output_logs，
       周期之间用空行隔开。
    """
    if not epoch_logs:
        return

    # 对当前周期内日志先进行过滤：若祖先规则已跳过，则当前规则也直接跳过
    processed_epoch = []
    for log in epoch_logs:
        ancestor_id = log.get("ancestor")
        if ancestor_id in global_noexecuted:
            global_noexecuted.add(log["id"])
            print(f"规则 {log['id']} 被跳过，因为祖先规则 {ancestor_id} 未执行成功")
        else:
            processed_epoch.append(log)

    # 筛选出需要执行的规则（状态未标记为 "skipped"）
    to_execute = [log for log in processed_epoch if log.get("status", "") != "skipped"]
    if to_execute:
        barrier = threading.Barrier(len(to_execute))
        threads = []
        lock = threading.Lock()
        for log in to_execute:
            thread = threading.Thread(target=execute_rule, args=(log, output_logs, lock, barrier, conflict_map))
            threads.append(thread)
            thread.start()
        for thread in threads:
            thread.join()
    output_logs.append("")  # 用空行分隔不同周期


def run_rules_concurrent_simulation(static_log_path, run_log_path, conflict_map):
    """
    模拟规则的并发执行：
    1. 读取 static_logs（不同周期用空行分隔）。
    2. 对每个周期调用 process_epoch，为每条规则创建线程并利用 Barrier 同步启动。
    3. 最终将所有周期的规则执行结果以日志形式写入 run_log_path。
    返回整个模拟的执行日志列表。
    """
    epochs_logs = read_static_logs(static_log_path)
    output_logs = []

    for epoch in epochs_logs:
        process_epoch(epoch, output_logs, conflict_map)

    # 将执行日志写入 run_log_path，保持与 static_logs 类似的格式（空行分隔周期）
    with open(run_log_path, "w", encoding="utf-8") as f:
        for entry in output_logs:
            if entry == "":
                f.write("\n")
            else:
                f.write(str(entry) + "\n")
    return output_logs


if __name__ == "__main__":
    # 静态日志文件路径
    static_log_path = r"E:\研究生信息收集\论文材料\IoT-Event-Detector\Detector\Vulnerability\Data\static_logs.txt"
    # 执行日志文件输出路径
    run_log_path = r"E:\研究生信息收集\论文材料\IoT-Event-Detector\Detector\Vulnerability\Data\run_logs.txt"
    # 获取 conflict_map：直接调用已实现的 get_conflict_map 函数

    conflict_map = get_conflict_map()

    run_rules_concurrent_simulation(static_log_path, run_log_path, conflict_map)

    # 读取日志，得到按轮次划分的日志数据
    epochs_logs = read_static_logs(run_log_path)

    vuln_dict1 = detectRaceCondition_per_epoch(epochs_logs)
    vuln_dict2 = detectVulnerability_all(epochs_logs)

    vuln_dict = {}
    for key in vuln_dict1.keys():
        vuln_dict[key] = vuln_dict1[key] + vuln_dict2.get(key, [])

    print("Vulnerability dict:", vuln_dict)

    for key, value in vuln_dict.items():
        print(f"{key}: {len(value)} 个元素")


