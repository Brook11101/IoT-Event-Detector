import threading
import time
import random
import ast

from Detector.Vulnerability.VulnerCount import get_conflict_map, detectRaceCondition_per_epoch, detectVulnerability_all

# 全局变量：跨周期记录已成功执行与未执行的规则id
global_executed = set()
global_noexecuted = set()

def read_static_logs(log_file_path):
    """
    读取日志文件，按空行分隔周期，
    返回一个列表，每个元素为该周期内的规则日志（字典列表）。
    假设每行是一个字典的字符串。
    """
    with open(log_file_path, "r", encoding="utf-8") as f:
        content = f.read().strip()
    epochs = content.split("\n\n")
    epochs_logs = []
    for epoch in epochs:
        logs = []
        for line in epoch.split("\n"):
            line = line.strip()
            if line:
                try:
                    log_entry = ast.literal_eval(line)
                    logs.append(log_entry)
                except Exception as e:
                    print(f"解析日志行出错: {line}, 错误: {e}")
        epochs_logs.append(logs)
    return epochs_logs

def execute_rule(rule, output_list, lock, barrier, conflict_map):
    """
    执行单条规则：
    1. 先等待 barrier，确保所有线程同步启动。
    2. 模拟延迟后检查当前规则的冲突集合（来自 conflict_map）是否与 global_executed 中已有的规则id有交集：
         - 如果有，说明冲突，不执行该规则，将其 id 加入 global_noexecuted，并打印信息（计为 TN）。
         - 如果没有，则模拟执行（延迟后），并将其 id 加入 global_executed，同时记录到 output_list（计为 TP）。
    """
    # 等待所有线程到达 barrier 同步启动
    barrier.wait()

    # 模拟执行延迟
    time.sleep(random.uniform(1, 2))

    with lock:
        conflict_ids = conflict_map.get(rule["id"], set())
        if conflict_ids & global_executed:
            global_noexecuted.add(rule["id"])
            print(f"规则 {rule['id']} 被跳过，冲突规则 {conflict_ids & global_executed} 已执行")
            # 可在 rule 中记录状态，但这里不再关心 status 细节
            return
        else:
            global_executed.add(rule["id"])
            output_list.append(rule)
    print(f"规则 {rule['id']} 执行成功")

def process_epoch(epoch_logs, output_list, conflict_map):
    """
    处理一个周期内的规则日志：
    1. 遍历 epoch_logs，如果某条规则的 ancestor 在 global_noexecuted 中，则直接跳过该规则，
       并将其 id 加入 global_noexecuted；
    2. 对未跳过的规则创建一个 Barrier，同步启动线程执行（调用 execute_rule）。
    3. 等待所有线程执行完毕后，在 output_list 中加入一个空行分隔不同周期。
    """
    if not epoch_logs:
        return

    # 先过滤：如果某规则的 ancestor 已在 global_noexecuted，则该规则直接跳过
    processed_epoch = []
    for log in epoch_logs:
        ancestor_id = log.get("ancestor")
        if ancestor_id in global_noexecuted:
            global_noexecuted.add(log["id"])
            print(f"规则 {log['id']} 被跳过，因为祖先规则 {ancestor_id} 未执行成功")
        else:
            processed_epoch.append(log)

    # 对未跳过的规则创建线程执行
    to_execute = [log for log in processed_epoch if log.get("status", "") != "skipped"]
    # to_execute = processed_epoch
    if to_execute:
        barrier = threading.Barrier(len(to_execute))
        threads = []
        lock = threading.Lock()
        for log in to_execute:
            thread = threading.Thread(target=execute_rule, args=(log, output_list, lock, barrier, conflict_map))
            threads.append(thread)
            thread.start()
        for thread in threads:
            thread.join()

    output_list.append("")  # 用空行分隔不同周期

def run_rules_concurrent_simulation(static_log_path, run_log_path, conflict_map):
    """
    模拟规则的并发执行：
    1. 读取 static_logs（周期之间用空行分隔）。
    2. 对每个周期调用 process_epoch，为每条规则创建线程并同步启动执行。
    3. 最终将所有周期的规则执行结果以日志形式写入 run_log_path，
       并返回整个模拟的执行日志列表。
    """
    epochs_logs = read_static_logs(static_log_path)
    output_logs = []

    for epoch in epochs_logs:
        process_epoch(epoch, output_logs, conflict_map)

    with open(run_log_path, "w", encoding="utf-8") as f:
        for entry in output_logs:
            if entry == "":
                f.write("\n")
            else:
                f.write(str(entry) + "\n")
    return output_logs

def count_vulnerabilities(epochs_logs):
    """
    对给定的日志（按周期划分）调用漏洞检测函数，统计 AL、ARN、ART、CBS、CC 五种干扰数量，
    作为 FP 的统计值。
    """
    vuln_dict1 = detectRaceCondition_per_epoch(epochs_logs)
    vuln_dict2 = detectVulnerability_all(epochs_logs)
    vuln_dict = {}
    for key in vuln_dict1.keys():
        vuln_dict[key] = vuln_dict1[key] + vuln_dict2.get(key, [])
    fp = 0
    for key in ["AL", "ARN", "ART", "CBS", "CC"]:
        fp += len(vuln_dict.get(key, []))
    return fp, vuln_dict

def total_rule_count(static_log_path):
    """
    读取静态日志文件，计算其中总的规则数（不包含空行）。
    """
    epochs_logs = read_static_logs(static_log_path)
    count = 0
    for epoch in epochs_logs:
        count += len(epoch)
    return count

if __name__ == "__main__":
    # 模拟实验重复次数
    num_rounds = 5

    # 静态日志文件路径
    static_log_path = r"E:\研究生信息收集\论文材料\IoT-Event-Detector\Detector\Vulnerability\Data\static_logs.txt"
    # 执行日志输出路径
    run_log_path = r"E:\研究生信息收集\论文材料\IoT-Event-Detector\Detector\Vulnerability\Data\run_logs.txt"

    # 获取 conflict_map，直接调用你已实现的 get_conflict_map 函数
    conflict_map = get_conflict_map()

    # 计算总规则数（静态日志中规则的总数）
    total_rules = total_rule_count(static_log_path)

    for round_index in range(num_rounds):
        print(f"\n========== 开始第 {round_index+1} 轮实验 ==========")
        # 清空全局集合
        global_executed.clear()
        global_noexecuted.clear()

        # 运行并发模拟
        run_rules_concurrent_simulation(static_log_path, run_log_path, conflict_map)

        # 读取执行日志文件，以便后续漏洞检测
        epochs_run_logs = read_static_logs(run_log_path)

        # 统计 FP：将 AL、ARN、ART、CBS、CC 数量相加
        fp, vuln_dict = count_vulnerabilities(epochs_run_logs)

        # TP 和 TN 分别为全局记录中已成功和跳过规则的数量
        tp = len(global_executed)
        tn = len(global_noexecuted)
        fn = total_rules - tp - tn

        print(f"第 {round_index+1} 轮实验统计结果:")
        print(f"总规则数: {total_rules}")
        print(f"TP（期望执行且执行）: {tp}")
        print(f"TN（应不执行且跳过）: {tn}")
        print(f"FP（错误执行的冲突数，即 AL+ARN+ART+CBS+CC）: {fp}")
        print(f"FN（未执行的期望规则）: {fn}")
        print("========== 第", round_index+1, "轮实验结束 ==========\n")
